import matplotlib.pyplot as plt
import numpy as np
import scipy.optimize as sopt

true_results = [
    (-100, 7.534424797774636),
    (-98, 5.696333189216324),
    (-96, 3.1835146258186278),
    (-94, 0.3448827414177389),
    (-92, -2.3960466042407464),
    (-90, -4.607666190523203),
    (-88, -5.919003275291804),
    (-86, -6.079786805614593),
    (-84, -5.002312956692161),
    (-82, -2.7784055345863052),
    (-80, 0.3313305731704461),
    (-78, 3.9344157722652917),
    (-76, 7.563904188569079),
    (-74, 10.74741223131181),
    (-72, 13.077056252314003),
    (-70, 14.269442717571447),
    (-68, 14.206415403038774),
    (-66, 12.950285772947446),
    (-64, 10.731278498554463),
    (-62, 7.909282506942583),
    (-60, 4.916022036559534),
    (-58, 2.1868178995878016),
    (-56, 0.09271549579283578),
    (-54, -1.1163390379090612),
    (-52, -1.3483733141795025),
    (-50, -0.680595263715392),
    (-48, 0.6567053726035867),
    (-46, 2.3208631850472066),
    (-44, 3.9155509060041997),
    (-42, 5.0580473061884135),
    (-40, 5.4442518183239095),
    (-38, 4.900998465862166),
    (-36, 3.417238325224382),
    (-34, 1.149014273701727),
    (-32, -1.6026861647859438),
    (-30, -4.437802539421297),
    (-28, -6.919621306093541),
    (-26, -8.643918593581866),
    (-24, -9.303901993853595),
    (-22, -8.74065369619595),
    (-20, -6.971031076390988),
    (-18, -4.188507787230684),
    (-16, -0.7366829270718738),
    (-14, 2.940521030066635),
    (-12, 6.364286086148616),
    (-10, 9.091808422995975),
    (-8, 10.781681656655048),
    (-6, 11.24361149069576),
    (-4, 10.464779796751555),
    (-2, 8.608842491956457),
    (0, 5.987840056419071),
    (2, 3.0115451750183895),
    (4, 0.12229973341539341),
    (6, -2.2743523323467256),
    (8, -3.872303478698424),
    (10, -4.510958393301271),
    (12, -4.197562640508542),
    (14, -3.1023795413950968),
    (16, -1.527623431228919),
    (18, 0.14477907112820965),
    (20, 1.5181720082958114),
    (22, 2.248451084404659),
    (24, 2.1028348399160075),
    (26, 1.0006701299136755),
    (28, -0.970332018224497),
    (30, -3.5651330863099306),
    (32, -6.418045900800262),
    (34, -9.099344867660804),
    (36, -11.182914894825533),
    (38, -12.31426651086173),
    (40, -12.268149550172984),
    (42, -10.986603786356227),
    (44, -8.591339943331953),
    (46, -5.368367610333075),
    (48, -1.727143752254811),
    (50, 1.8594801851026173),
    (52, 4.925214586169027),
    (54, 7.079334065821906),
    (56, 8.06401596156578),
    (58, 7.791135789690124),
    (60, 6.3528663143516475),
    (62, 4.004538982336003),
    (64, 1.1225766421971919),
    (66, -1.855790944996615),
    (68, -4.501477097990962),
    (70, -6.460271171440375),
    (72, -7.50685909063316),
    (74, -7.577678618527118),
    (76, -6.77753054393271),
    (78, -5.359038529343097),
    (80, -3.6783597014024014),
    (82, -2.134313948815297),
    (84, -1.100727108033691),
    (86, -0.8628566122312336),
    (88, -1.5681182079779674),
    (90, -3.1990618396709927),
    (92, -5.573012732397188),
    (94, -8.36855847960797),
    (96, -11.174794223217948),
    (98, -13.555610946290713),
    (100, -15.118900474608456),
]

x_true = np.array([pair[0] for pair in true_results])
y_true = np.array([pair[1] for pair in true_results])


def our_function(x: float | np.ndarray, params: np.ndarray):
    s1, s2, s3, c1, c2, c3, l1, l2 = params
    return s1 * np.sin(s2 * x + s3) + c1 * np.cos(c2 * x + c3) + l1 * x + l2


def loss(params: np.ndarray):
    each_x_loss = (our_function(x_true, params) - y_true) ** 2
    return each_x_loss.sum()


def loss_gradient(params: np.ndarray):
    a, b, c, d, e, f, g, h = params

    x = x_true
    our_function_grad = np.array([
        np.sin(b * x + c),
        a * x * np.cos(b * x + c),
        a * np.cos(b * x + c),
        np.cos(e * x + f),
        -d * x * np.sin(e * x + f),
        -d * np.sin(e * x + f),
        x,
        [1] * len(x)
    ])

    return (2 * (our_function(x_true, params) - y_true) * our_function_grad).sum(axis=1)


rate = 0.000001
epsilon = 0.001
max_iter = 10000

params = np.array([-7, -np.pi / 4, 5, -7, -np.pi / 4, 5, 3, -1])

a = sopt.minimize(loss, params, jac=loss_gradient, tol=epsilon)
print(a)

# history = []
#
# for _ in range(max_iter):
#     loss_sum = loss(params).sum()
#     history.append(loss_sum)
#     if loss_sum > epsilon:
#         grad = loss_gradient(params)
#         params -= rate * grad
#     else:
#         break
#
# print(history[-1])
# print(params)
new_x = np.linspace(-100, 100, 1001)

fig, ax = plt.subplots(2, 1, figsize=(5, 7))
ax[0].plot(x_true, y_true, 'o')
ax[0].plot(new_x, our_function(new_x, a.x))

# ax[1].plot(history)
# ax[1].set_title("Loss function")
# ax[1].set_xlabel("Iteration")
# ax[1].set_ylabel("Loss")

plt.show()
