import math as m
from scipy.interpolate import CubicSpline as spline
import matplotlib.pyplot as plt
import numpy as np

epsilon = 0.001
results = [
    (-100, 7.534424797774636),
    (-98, 5.696333189216324),
    (-96, 3.1835146258186278),
    (-94, 0.3448827414177389),
    (-92, -2.3960466042407464),
    (-90, -4.607666190523203),
    (-88, -5.919003275291804),
    (-86, -6.079786805614593),
    (-84, -5.002312956692161),
    (-82, -2.7784055345863052),
    (-80, 0.3313305731704461),
    (-78, 3.9344157722652917),
    (-76, 7.563904188569079),
    (-74, 10.74741223131181),
    (-72, 13.077056252314003),
    (-70, 14.269442717571447),
    (-68, 14.206415403038774),
    (-66, 12.950285772947446),
    (-64, 10.731278498554463),
    (-62, 7.909282506942583),
    (-60, 4.916022036559534),
    (-58, 2.1868178995878016),
    (-56, 0.09271549579283578),
    (-54, -1.1163390379090612),
    (-52, -1.3483733141795025),
    (-50, -0.680595263715392),
    (-48, 0.6567053726035867),
    (-46, 2.3208631850472066),
    (-44, 3.9155509060041997),
    (-42, 5.0580473061884135),
    (-40, 5.4442518183239095),
    (-38, 4.900998465862166),
    (-36, 3.417238325224382),
    (-34, 1.149014273701727),
    (-32, -1.6026861647859438),
    (-30, -4.437802539421297),
    (-28, -6.919621306093541),
    (-26, -8.643918593581866),
    (-24, -9.303901993853595),
    (-22, -8.74065369619595),
    (-20, -6.971031076390988),
    (-18, -4.188507787230684),
    (-16, -0.7366829270718738),
    (-14, 2.940521030066635),
    (-12, 6.364286086148616),
    (-10, 9.091808422995975),
    (-8, 10.781681656655048),
    (-6, 11.24361149069576),
    (-4, 10.464779796751555),
    (-2, 8.608842491956457),
    (0, 5.987840056419071),
    (2, 3.0115451750183895),
    (4, 0.12229973341539341),
    (6, -2.2743523323467256),
    (8, -3.872303478698424),
    (10, -4.510958393301271),
    (12, -4.197562640508542),
    (14, -3.1023795413950968),
    (16, -1.527623431228919),
    (18, 0.14477907112820965),
    (20, 1.5181720082958114),
    (22, 2.248451084404659),
    (24, 2.1028348399160075),
    (26, 1.0006701299136755),
    (28, -0.970332018224497),
    (30, -3.5651330863099306),
    (32, -6.418045900800262),
    (34, -9.099344867660804),
    (36, -11.182914894825533),
    (38, -12.31426651086173),
    (40, -12.268149550172984),
    (42, -10.986603786356227),
    (44, -8.591339943331953),
    (46, -5.368367610333075),
    (48, -1.727143752254811),
    (50, 1.8594801851026173),
    (52, 4.925214586169027),
    (54, 7.079334065821906),
    (56, 8.06401596156578),
    (58, 7.791135789690124),
    (60, 6.3528663143516475),
    (62, 4.004538982336003),
    (64, 1.1225766421971919),
    (66, -1.855790944996615),
    (68, -4.501477097990962),
    (70, -6.460271171440375),
    (72, -7.50685909063316),
    (74, -7.577678618527118),
    (76, -6.77753054393271),
    (78, -5.359038529343097),
    (80, -3.6783597014024014),
    (82, -2.134313948815297),
    (84, -1.100727108033691),
    (86, -0.8628566122312336),
    (88, -1.5681182079779674),
    (90, -3.1990618396709927),
    (92, -5.573012732397188),
    (94, -8.36855847960797),
    (96, -11.174794223217948),
    (98, -13.555610946290713),
    (100, -15.118900474608456),
]
prediction = {
    's1': -7,
    's2': -m.pi / 4,
    's3': 5,
    'c1': -7,
    'c2': -m.pi / 4,
    'c3': 5,
    'l1': 3,
    'l2': -1,
}

__x = []
__y = []

for result in results:
    __x.append(result[0])
    __y.append(result[1])

spl = spline(__x, __y)

def their_function(x):
    return float(spl(x))

def our_function(x):
    s1, s2, s3, c1, c2, c3, l1, l2 = prediction.values()
    return s1 * m.sin(s2 * x + s3) + c1 * m.cos(c2 * x + c3) + l1 * x + l2

def loss(x):
    return (their_function(x) - our_function(x)) ** 2

def calculate_gradient(x, y, rate):
    s1, s2, s3, c1, c2, c3, l1, l2 = prediction.values()

    # partial derivative by s1
    ds1 = -2 * m.sin(s2 * x + s3) * (c1 * m.cos(c2 * x + c3) + l1 * x + l2 - s1 * m.sin(s1 * x + s3) + y)

    # partial derivative by s2
    ds2 = -2 * s1 * x * m.cos(s2 * x + s3) * (c1 * m.cos(c2 * x + c3) + l1 * x + l2 - s1 * m.sin(s2 * x + s3) + y)

    # partial derivative by s3
    ds3 = -2 * s1 * m.cos(s3 + s2 * x) * (l2 + l1 * x + y + c1 * m.cos(c3 + c2 * x) - s1 * m.sin(s3 + s2 * x))

    # partial derivative by c1
    dc1 = 2 * m.cos(c2 * x + c3) * (c1 * m.cos(c2 * x + c3) + l1 * x + l2 - s1 * m.sin(s2 * x + s3) + y)

    # partial derivative by c2
    dc2 = -2 * c1 * x * m.sin(c2 * x + c3) * (c1 * m.cos(c2 * x + c3) + l1 * x + l2 - s1 * m.sin(s2 * x + s3) + y)

    # partial derivative by c3
    dc3 = -2 * c1 * m.sin(c2 * x + c3) * (c1 * m.cos(c2 * x + c3) + l1 * x + l2 - s1 * m.sin(s2 * x + s3) + y)

    # partial derivative by l1
    dl1 = 2 * x * (c1 * m.cos(c2 * x + c3) + l1 * x + l2 - s1 * m.sin(s2 * x + s3) + y)

    # partial derivative by l2
    dl2 = 2 * (c1 * m.cos(c2 * x + c3) + l1 * x + l2 - s1 * m.sin(s2 * x + s3) + y)

    prediction['s1'] -= ds1 * rate
    prediction['s2'] -= ds2 * rate
    prediction['s3'] -= ds3 * rate
    prediction['c1'] -= dc1 * rate
    prediction['c2'] -= dc2 * rate
    prediction['c3'] -= dc3 * rate
    prediction['l1'] -= dl1 * rate
    prediction['l2'] -= dl2 * rate

rate = 0.1

while True:
    loss_sum = sum([loss(x) for x in __x])
    if loss_sum > epsilon:
        for result in results:
            calculate_gradient(result[0], result[1], rate)
    else:
        break


new_x = np.linspace(-100, 100, 1001)

fig, ax = plt.subplots(2, 1, figsize=(5, 7))
ax[0].plot(__x, __y, 'o')
ax[0].plot(new_x, our_function)

plt.show()

